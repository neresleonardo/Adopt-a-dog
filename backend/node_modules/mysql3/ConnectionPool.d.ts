/// <reference types="node" />
import { PoolConfig as _PoolConfig } from "mysql";
import { SqlFrag } from './Sql';
import { GeometryType } from "mysql";
import SqlMode from "./SqlMode";
import { PoolConnection as _PoolConnection } from "mysql";
export interface PoolConfig extends Omit<_PoolConfig, 'typeCast' | 'supportBigNumbers' | 'bigNumberStrings'> {
    /**
     * Print SQL queries to STDOUT before executing them.
     */
    printQueries?: boolean;
    typeCast?: (field: FieldInfo, next: NextFn) => any;
    /**
     * @deprecated Set in my.cnf under [mysqld]
     */
    sqlMode?: SqlMode[] | string | null;
    /**
     * Enable or disable foreign key checks for the current session. May ease migration scripts, but not recommended
     * for production usage.
     */
    foreignKeyChecks?: boolean | null;
    /**
     * If this variable is enabled, UPDATE and DELETE statements that do not use a key in the WHERE clause or a LIMIT clause produce an error. This makes it possible to catch UPDATE and DELETE statements where keys are not used properly and that would probably change or delete a large number of rows.
     *
     * @link https://mariadb.com/kb/en/library/server-system-variables/#sql_safe_updates
     * @link https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sql_safe_updates
     * @deprecated Set in my.cnf under [mysqld]
     */
    safeUpdates?: boolean | null;
    /**
     * Array of SQL statements to execute upon connection.
     */
    initSql?: Array<SqlFrag>;
}
export declare type NextFn = () => void;
export declare type Types = 'DECIMAL' | 'TINY' | 'SHORT' | 'LONG' | 'FLOAT' | 'DOUBLE' | 'NULL' | 'TIMESTAMP' | 'LONGLONG' | 'INT24' | 'DATE' | 'TIME' | 'DATETIME' | 'YEAR' | 'NEWDATE' | 'VARCHAR' | 'BIT' | 'TIMESTAMP2' | 'DATETIME2' | 'TIME2' | 'JSON' | 'NEWDECIMAL' | 'ENUM' | 'SET' | 'TINY_BLOB' | 'MEDIUM_BLOB' | 'LONG_BLOB' | 'BLOB' | 'VAR_STRING' | 'STRING' | 'GEOMETRY';
export interface FieldInfo {
    catalog: string;
    db: string;
    table: string;
    orgTable: string;
    name: string;
    orgName: string;
    charsetNr: number;
    length: number;
    type: Types;
    flags: number;
    decimals: number;
    default?: string;
    zeroFill: boolean;
    protocol41: boolean;
    string(): string | null;
    buffer(): Buffer | null;
    geometry(): GeometryType | null;
}
export interface OkPacket {
    fieldCount: number;
    affectedRows: number;
    insertId: number;
    serverStatus: number;
    warningCount: number;
    message: string;
    protocol41: boolean;
    changedRows: number;
}
export declare class ConnectionPool {
    private pool;
    private readonly config;
    constructor(config: PoolConfig);
    query<TRecord extends object = Record<string, any>>(query: SqlFrag): Promise<TRecord[]>;
    row<TRecord extends object = Record<string, any>>(query: SqlFrag): Promise<TRecord | null>;
    value<TValue = string>(query: SqlFrag): Promise<TValue | null>;
    exec(query: SqlFrag): Promise<OkPacket>;
    stream<TRecord extends object = Record<string, any>>(query: SqlFrag): AsyncGenerator<TRecord, void, any>;
    withConnection<TResult>(callback: (conn: PoolConnection) => Promise<TResult>): Promise<TResult>;
    transaction<TResult>(callback: ((conn: PoolConnection) => Promise<TResult>) | SqlFrag[]): Promise<TResult>;
    private _wrap;
    close(): Promise<unknown>;
}
declare class PoolConnection {
    private readonly conn;
    private readonly printQueries;
    constructor(conn: _PoolConnection, printQueries: boolean);
    query(query: SqlFrag): Promise<any>;
}
export {};
